import Foundation
import CZUtils

public class Promise {
  public typealias Input = Any
  public typealias Result = Any
  
  /// Resolve callback closure.
  public typealias Resolve = (Input?) -> Void
  /// Reject callback closure.
  public typealias Reject = (Error?) -> Void
  /// Pre-execution closure: the real preExecution will be when resolve() / reject() gets called.
  public typealias Execution = (@escaping Resolve, @escaping Reject) -> Void
  private let preExecution: Execution
  
  /// Error of preExecution.
  private var error: Error?
  
  /// Then callback closure.
  public typealias Then<T, U> = (T?) -> U?
  
  /// Array of chaining then closures.
  /// - Note: RootPromise maintains all `thenClosures`, instead of each Promise maintaining its own.
  private var thenClosures = [Then<Input, Promise>]()
  /// Promises generated by `thenClosure` asynchronously.
  // private var thenPromises = [Promise]()
  private var currPromiseIndex = 0

  /// Catch callback closure.
  public typealias Catch = (Error?) -> Void
  private var catchClosure: Catch?
  
  /// Semaphore for async/await signal.
  private var semaphore: DispatchSemaphore?
  
  private var prevThenResult: Input?
  private weak var rootPromise: Promise?
  private var nextPromise: Promise?
  
  public static var allPromisesSuccessString: String {
    return "Succeed to execute all promises."
  }
  
  /// Initialize with `preExecution` closure.
  /// Call `resolve()` on success, and call `reject()` on failure.
  public init(root rootPromise: Promise?,
              _ preExecution: @escaping Execution) {
    self.rootPromise = rootPromise
    self.preExecution = preExecution
    
    if self.rootPromise == nil {
      // Set `rootPromise` with self if it's nil, which will be held weak reference.
      self.rootPromise = self
    }
  }
  
  /// `thenClosure` that will be called by `resolve()`: `then()` returns Promise.
  @discardableResult
  public func then(_ thenClosure: @escaping Then<Input, Promise>) -> Promise {
    // 1. Store `thenClosure`.
    let hasQueuedThenClosure = rootPromise!.hasQueuedThenClosure()
    rootPromise?.enqueueThenClosure(thenClosure)
    
    // 2. preExecution(): if has no thenClosure in queue - no previous resolve() left.
    // The remaining promises will be prepared in its prev promise's resolve().
    // `preExecution`: just prepare - the real execution will be when resolve() / reject() gets called.
    if !hasQueuedThenClosure {
      preExecution(resolve, reject)
    }
    
    return self
  }
  
  /// `catch` function that will be called on `reject()`.
  @discardableResult
  public func `catch`(_ catchClosure: @escaping Catch) -> Promise {
    self.catchClosure = catchClosure
    return self
  }
  
  // MARK: - RootPromise
  
  func hasQueuedThenClosure() -> Bool {
    return thenClosures.count > 0
  }
  
  func enqueueThenClosure(_ thenClosure: @escaping Then<Input, Promise>) {
    thenClosures.append(thenClosure)
  }
  
  func dequeNextThenClosures() -> Then<Input, Promise>? {
    guard hasQueuedThenClosure() else {
      return nil
    }
    let nextThenClosure = thenClosures.removeFirst()
    currPromiseIndex += 1
    return nextThenClosure
    
//    guard currPromiseIndex <= thenClosures.count - 1 else {
//      return nil
//    }
//    let nextThenClosure = thenClosures[currPromiseIndex]
//    currPromiseIndex += 1
//    return nextThenClosure
  }
  
}


// MARK: - Resolve / Reject

private extension Promise {
  /// Function will be called on preExecution success.
  /// resolve(): completion with the current result.
  func resolve(_ result: Input?) {
    rootPromise?.prevThenResult = result
    
    guard let nextThenClosure = rootPromise?.dequeNextThenClosures() else {
      dbgPrintWithFunc(self, "Completed all promises! currPromiseIndex = \(currPromiseIndex), thenClosures.count = \(thenClosures.count)")
      return
    }
    
    // Set nextResult: `nextThenClosure` isn't nil, it will call nextPromise with the current `result`.
    let nextResult = result

    // Generate nextPromise: `nextThenClosure` with `nextResult`.
    nextPromise = nextThenClosure(nextResult)
    
    // Call nextPromise's preExecution: prepare.
    nextPromise?.preExecution(nextPromise!.resolve, nextPromise!.reject)
    
    // No need to call nextPromise: will be called by nextPromise itself.
    // nextPromise?.resolve(nextInput)    
  }
  
  /// Function will be called on preExecution failure.
  func reject(_ error: Error?) {
    // Call `then` with `error`.
    catchClosure?(error)
  }
}
